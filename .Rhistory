library(tidyverse)
library(MASS)
library(emmeans)
library(scales)
library(buildmer)
library(lme4)
library(kableExtra)
library(papaja)
library(qwraps2)
library(lmerTest)
library(ggdist)
library(ggpubr)
library(conflicted)
library(ggtext)
install.packages("")
library(r2glmm)
library(grid)
library(DescTools)
library(Matrix)
passed <- read.csv("data/data_tidy.csv")
passed <- passed %>%
mutate(
subject = factor(pid),
lang_group = factor(lang_group),
item = factor(item),
direction = factor(direction)
)
contrasts(passed$direction) <- matrix(c(-0.5, 0.5))
contrasts(passed$lang_group) <- matrix(c(-0.5, 0.5))
comparison <- function(model) {
parens <- function(x) paste0("(",x,")")
onlyBars <- function(form) reformulate(sapply(findbars(form),
function(x)  parens(deparse(x))),
response=".")
onlyBars(formula(model))
cmpr_model <- update(model,onlyBars(formula(model)))
return(cmpr_model)
}
anova_results <- function(model, cmpr_model) {
model_name <- deparse(substitute(model))
if (class(model) == "buildmer") model <- model@model
if (class(cmpr_model) == "buildmer") cmpr_model <- cmpr_model@model
anova_output <- anova(model, cmpr_model)
assign(paste0(model_name, ".Chisq"),
anova_output$Chisq[2],
envir = .GlobalEnv)
assign(paste0(model_name, ".df"),
anova_output$Df[2],
envir = .GlobalEnv)
assign(paste0(model_name, ".p"),
anova_output$`Pr(>Chisq)`[2],
envir = .GlobalEnv)
}
contrasts_extract <- function(model) {
model_name <- deparse(substitute(model))
if (class(model) == "buildmer") model <- model@model
EMMs <- emmeans(model, pairwise ~ lang * direction)
contrast_df <- as.data.frame(EMMs[2]) %>%
rename_with(str_replace,
pattern = "contrasts.", replacement = "",
matches("contrasts")) %>%
rename_with(str_to_title, !starts_with("p")) %>%
select(c("Contrast", "Z.ratio", "p.value"))
return(contrast_df)
}
make_sig_table <- function(model) {
# If model is from buildmer, extract the lmer model
if (class(model) == "buildmer") model <- model@model
# Extract summary table and rename columns
table_df <- as.data.frame(summary(model)[10]) %>%
dplyr::rename("Estimate" = "coefficients.Estimate",
"Standard Error" = "coefficients.Std..Error",
"df" = "coefficients.df",
"t-value" = "coefficients.t.value",
"p" = "coefficients.Pr...t..") %>%
dplyr::mutate(p = scales::pvalue(p))
# Add R² values from r2beta
r_squared <- r2beta(model, method = "nsj") %>%
dplyr::mutate("Effect" = dplyr::recode(Effect,
"direction" = "direction",
"lang_group" = "lang_group",
"lang_group:direction" = "lang_group x direction")) %>%
dplyr::select(Effect, Rsq) %>%
dplyr::mutate(Rsq = round(Rsq, 3)) %>%
dplyr::mutate(Rsq = ifelse(dplyr::row_number() == 1, NA, Rsq))  # NA for intercept
# Set row names
rownames(table_df) <- c(
"intercept",
"direction",
"lang_group",
"lang_group x direction")
# Combine data frames
result_table <- cbind(table_df, `R²` = r_squared$Rsq)
# Print the table
print(result_table)
}
model <- buildmer(reaction_t ~ direction * lang_group +
(1 + direction*lang_group | subject) +
(1 + direction*lang_group | item),
data = passed)
library(tidyverse)
library(MASS)
library(emmeans)
library(scales)
library(buildmer)
library(lme4)
library(kableExtra)
library(papaja)
library(qwraps2)
library(lmerTest)
library(ggdist)
library(ggpubr)
library(conflicted)
library(ggtext)
install.packages("")
library(r2glmm)
library(grid)
library(DescTools)
library(Matrix)
passed <- read.csv("data/data_tidy.csv")
passed <- passed %>%
mutate(
subject = factor(pid),
lang_group = factor(lang_group),
item = factor(item),
direction = factor(direction)
)
contrasts(passed$direction) <- matrix(c(-0.5, 0.5))
contrasts(passed$lang_group) <- matrix(c(-0.5, 0.5))
comparison <- function(model) {
parens <- function(x) paste0("(",x,")")
onlyBars <- function(form) reformulate(sapply(findbars(form),
function(x)  parens(deparse(x))),
response=".")
onlyBars(formula(model))
cmpr_model <- update(model,onlyBars(formula(model)))
return(cmpr_model)
}
anova_results <- function(model, cmpr_model) {
model_name <- deparse(substitute(model))
if (class(model) == "buildmer") model <- model@model
if (class(cmpr_model) == "buildmer") cmpr_model <- cmpr_model@model
anova_output <- anova(model, cmpr_model)
assign(paste0(model_name, ".Chisq"),
anova_output$Chisq[2],
envir = .GlobalEnv)
assign(paste0(model_name, ".df"),
anova_output$Df[2],
envir = .GlobalEnv)
assign(paste0(model_name, ".p"),
anova_output$`Pr(>Chisq)`[2],
envir = .GlobalEnv)
}
contrasts_extract <- function(model) {
model_name <- deparse(substitute(model))
if (class(model) == "buildmer") model <- model@model
EMMs <- emmeans(model, pairwise ~ lang * direction)
contrast_df <- as.data.frame(EMMs[2]) %>%
rename_with(str_replace,
pattern = "contrasts.", replacement = "",
matches("contrasts")) %>%
rename_with(str_to_title, !starts_with("p")) %>%
select(c("Contrast", "Z.ratio", "p.value"))
return(contrast_df)
}
make_sig_table <- function(model) {
# If model is from buildmer, extract the lmer model
if (class(model) == "buildmer") model <- model@model
# Extract summary table and rename columns
table_df <- as.data.frame(summary(model)[10]) %>%
dplyr::rename("Estimate" = "coefficients.Estimate",
"Standard Error" = "coefficients.Std..Error",
"df" = "coefficients.df",
"t-value" = "coefficients.t.value",
"p" = "coefficients.Pr...t..") %>%
dplyr::mutate(p = scales::pvalue(p))
# Add R² values from r2beta
r_squared <- r2beta(model, method = "nsj") %>%
dplyr::mutate("Effect" = dplyr::recode(Effect,
"direction" = "direction",
"lang_group" = "lang_group",
"lang_group:direction" = "lang_group x direction")) %>%
dplyr::select(Effect, Rsq) %>%
dplyr::mutate(Rsq = round(Rsq, 3)) %>%
dplyr::mutate(Rsq = ifelse(dplyr::row_number() == 1, NA, Rsq))  # NA for intercept
# Set row names
rownames(table_df) <- c(
"intercept",
"direction",
"lang_group",
"lang_group x direction")
# Combine data frames
result_table <- cbind(table_df, `R²` = r_squared$Rsq)
# Print the table
print(result_table)
}
model <- buildmer(reaction_t ~ direction * lang_group +
(1 + direction*lang_group | subject) +
(1 + direction*lang_group | item),
data = passed)
model <- model@model
model_cmpr <- comparison(model)
anova_results(model, model_cmpr)
make_sig_table(model)
make_sig_table(model)
function (x, make.names = FALSE, value)
{
if (!is.data.frame(x))
x <- as.data.frame(x)
n <- .row_names_info(x, 2L)
if (is.null(value)) {
attr(x, "row.names") <- .set_row_names(n)
return(x)
}
if (is.object(value) || !is.integer(value))
value <- as.character(value)
if (n == 0L) {
if (!is.null(attr(x, "row.names")) && length(value) >
0L)
stop("invalid 'row.names' length")
}
else if (length(value) != n) {
if (isFALSE(make.names))
stop("invalid 'row.names' length")
else if (is.na(make.names)) {
attr(x, "row.names") <- .set_row_names(n)
return(x)
}
else if (!isTRUE(make.names))
stop("invalid 'make.names'")
else if ((nv <- length(value)) < n)
value <- c(value, rep_len(value[nv], n - nv))
else value <- value[seq_len(n)]
}
if (anyDuplicated(value)) {
if (isFALSE(make.names)) {
nonuniq <- sort(unique(value[duplicated(value)]))
warning(ngettext(length(nonuniq), sprintf("non-unique value when setting 'row.names': %s",
sQuote(nonuniq[1L])), sprintf("non-unique values when setting 'row.names': %s",
paste(sQuote(nonuniq), collapse = ", "))), domain = NA,
call. = FALSE)
stop("duplicate 'row.names' are not allowed")
}
else if (is.na(make.names)) {
value <- .set_row_names(if (n == 0L && is.null(.row_names_info(x,
0L)) && length(x) > 0L)
length(x[[1L]])
else n)
}
else if (!isTRUE(make.names))
stop("invalid 'make.names'")
else value <- make.names(value, unique = TRUE)
}
else if (anyNA(value)) {
if (isFALSE(make.names))
stop("missing values in 'row.names' are not allowed")
if (is.na(make.names))
value <- .set_row_names(if (n > 0)
n
else length(value))
else if (!isTRUE(make.names))
stop("invalid 'make.names'")
else value <- make.names(value, unique = TRUE)
}
attr(x, "row.names") <- value
x
}
# Combine data frames
result_table <- cbind(table_df, `R²` = r_squared$Rsq)
make_sig_table <- function(model) {
# If model is from buildmer, extract the lmer model
if (class(model) == "buildmer") model <- model@model
# Extract summary table and rename columns
table_df <- as.data.frame(summary(model)[10]) %>%
dplyr::rename("Estimate" = "coefficients.Estimate",
"Standard Error" = "coefficients.Std..Error",
"df" = "coefficients.df",
"t-value" = "coefficients.t.value",
"p" = "coefficients.Pr...t..") %>%
dplyr::mutate(p = scales::pvalue(p))
# Add R² values from r2beta
r_squared <- r2beta(model, method = "nsj") %>%
dplyr::mutate("Effect" = dplyr::recode(Effect,
"direction" = "direction",
"lang_group" = "lang_group",
"lang_group:direction" = "lang_group x direction")) %>%
dplyr::select(Effect, Rsq) %>%
dplyr::mutate(Rsq = round(Rsq, 3)) %>%
dplyr::mutate(Rsq = ifelse(dplyr::row_number() == 1, NA, Rsq))  # NA for intercept
# Set row names
rownames(table_df) <- c("intercept", "direction", "lang_group", "lang_group x direction")
# Combine data frames
result_table <- cbind(table_df, `R²` = r_squared$Rsq)
# Print the table
print(result_table)
}
make_sig_table(model)
# Set row names
rownames(table_df) <- c( "direction", "lang_group", "lang_group x direction")
make_sig_table <- function(model) {
# If model is from buildmer, extract the lmer model
if (class(model) == "buildmer") model <- model@model
# Extract summary table and rename columns
table_df <- as.data.frame(summary(model)[10]) %>%
dplyr::rename("Estimate" = "coefficients.Estimate",
"Standard Error" = "coefficients.Std..Error",
"df" = "coefficients.df",
"t-value" = "coefficients.t.value",
"p" = "coefficients.Pr...t..") %>%
dplyr::mutate(p = scales::pvalue(p))
# Add R² values from r2beta
r_squared <- r2beta(model, method = "nsj") %>%
dplyr::mutate("Effect" = dplyr::recode(Effect,
"direction" = "direction",
"lang_group" = "lang_group",
"lang_group:direction" = "lang_group x direction")) %>%
dplyr::select(Effect, Rsq) %>%
dplyr::mutate(Rsq = round(Rsq, 3)) %>%
dplyr::mutate(Rsq = ifelse(dplyr::row_number() == 1, NA, Rsq))  # NA for intercept
# Set row names
rownames(table_df) <- c( "direction", "lang_group", "lang_group x direction")
# Combine data frames
result_table <- cbind(table_df, `R²` = r_squared$Rsq)
# Print the table
print(result_table)
}
make_sig_table(model)
make_sig_table <- function(model) {
if (class(model) == "buildmer") model <- model@model
table_df <- as.data.frame(summary(model)$coefficients) %>%
dplyr::rename(
Estimate = Estimate,
`Standard Error` = `Std. Error`,
df = df,
`t-value` = `t value`,
p = `Pr(>|t|)`
) %>%
dplyr::mutate(p = format.pval(p, digits = 3, eps = .001))
r_squared <- r2beta(model, method = "nsj") %>%
dplyr::mutate(Effect = dplyr::recode(Effect,
"direction" = "direction",
"lang_group" = "lang_group",
"lang_group:direction" = "lang_group x direction")) %>%
dplyr::select(Effect, Rsq) %>%
dplyr::mutate(Rsq = round(Rsq, 3)) %>%
dplyr::mutate(Rsq = ifelse(dplyr::row_number() == 1, NA, Rsq))
rownames(table_df) <- rownames(table_df)  # Or skip changing if uncertain
result_table <- cbind(table_df, `R²` = r_squared$Rsq)
print(result_table)
}
model <- buildmer(reaction_t ~ direction * lang_group +
(1 + direction*lang_group | subject) +
(1 + direction*lang_group | item),
data = passed)
make_sig_table <- function(model) {
if (class(model) == "buildmer") model <- model@model
table_df <- as.data.frame(summary(model)$coefficients) %>%
dplyr::rename(
Estimate = Estimate,
`Standard Error` = `Std. Error`,
df = df,
`t-value` = `t value`,
p = `Pr(>|t|)`
) %>%
dplyr::mutate(p = format.pval(p, digits = 3, eps = .001))
r_squared <- r2beta(model, method = "nsj") %>%
dplyr::mutate(Effect = dplyr::recode(Effect,
"direction" = "direction",
"lang_group" = "lang_group",
"lang_group:direction" = "lang_group x direction")) %>%
dplyr::select(Effect, Rsq) %>%
dplyr::mutate(Rsq = round(Rsq, 3)) %>%
dplyr::mutate(Rsq = ifelse(dplyr::row_number() == 1, NA, Rsq))
rownames(table_df) <- rownames(table_df)  # Or skip changing if uncertain
result_table <- cbind(table_df, `R²` = r_squared$Rsq)
print(result_table)
}
model <- model@model
model_cmpr <- comparison(model)
anova_results(model, model_cmpr)
make_sig_table(model)
model <- buildmer(accuracy ~ direction * lang_group +
(1 + direction*lang_group | subject) +
(1 + direction*lang_group | item),
data = passed)
model <- model@model
model_cmpr <- comparison(model)
model <- buildmer(accuracy ~ direction * lang_group +
(1 + direction*lang_group | subject) +
(1 + direction*lang_group | item),
family = binomial(),
data = passed)
model <- buildmer(accuracy ~ direction * lang_group +
(1 + direction*lang_group | subject) +
(1 + direction*lang_group | item),
family = binomial(),
data = passed)
model <- model@model
model_cmpr <- comparison(model)
anova_results(model, model_cmpr)
make_sig_table(model)
model_cmpr <- comparison(model)
model <- model@model
model_cmpr <- comparison(model)
anova_results(model, model_cmpr)
make_sig_table(model)
rlang::last_trace()
library(tidyverse)
library(lme4)
library(lmerTest)
library(ggplot2)
library(buildmer)
library(emmeans)
tidied_data <- read.csv("data/data_tidy.csv")
# Prepare data for modelling
#transform data to factor
tidied_data <- tidied_data %>%
mutate(
subject = factor(pid),
lang_group = factor(lang_group),
item = factor(item),
direction = factor(direction)
)
contrasts(tidied_data$direction) <- matrix(c(-0.5, 0.5))
contrasts(tidied_data$lang_group) <- matrix(c(-0.5, 0.5))
contrasts(tidied_reg_data$direction) <- matrix(c(.5, -.5))
contrasts(tidied_reg_data$lang_group) <- matrix(c(.5, -.5))
#Accuracy
binomial_model <- buildmer(  accuracy ~ lang_group * direction +
(1 | subject) +
(1 | item),
data = tidied_reg_data,
buildmerControl = list(include = 'accuracy ~ direction   * lang_group ' ),
family = binomial()
)
#summaries Accuracy
tidied_reg_data <- tidied_data %>%
mutate(subject = factor(pid),
lang_group = factor (lang_group),
item = factor(item),
direction = factor(direction)
)
contrasts(tidied_reg_data$direction) <- matrix(c(.5, -.5))
contrasts(tidied_reg_data$lang_group) <- matrix(c(.5, -.5))
#Accuracy
binomial_model <- buildmer(  accuracy ~ lang_group * direction +
(1 | subject) +
(1 | item),
data = tidied_reg_data,
buildmerControl = list(include = 'accuracy ~ direction   * lang_group ' ),
family = binomial()
)
binomial_model <- binomial_model@model
summary (binomial_model)
null_binomial_model <- glmer(accuracy  ~
(1 | subject),
data = tidied_reg_data,
family = binomial)
anova(binomial_model, null_binomial_model)
tidied_data %>%
filter(!is.na(reaction_t)) %>%
ggplot(aes(x = interaction( direction, lang_group), y = reaction_t, colour = interaction(direction, lang_group)) ) +
geom_violin() +
geom_jitter(width = .1, alpha = .2) +
stat_summary(    fun.data = mean_cl_boot,color = "black",size = 0.8)+
guides(colour = FALSE) +
labs(x = "language x direction",
y = "reaction time (ms.)") +
theme_minimal()+
coord_flip()
# Visualise the accuracy barplot
ggplot(summary_data, aes(x = lang_group, y = mean_accuracy, fill = direction)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.7),width = 0.4,alpha = 0.5,
color = "black") +
geom_errorbar(aes(ymin = mean_accuracy - se_accuracy , ymax = mean_accuracy + se_accuracy ),
position = position_dodge(width = 0.7), width = 0.2) +
geom_hline(yintercept = 0.94, color = "black", size = 0.3)+
coord_cartesian(ylim = c(0.95, 1.0) ) +
labs(
title = "Accuracy by Direction and Participants' Group",
x = "",
y = "Mean Accuracy",
fill = "Graph Direction"
)+
scale_fill_discrete( name = "Graph Direction", labels = c("LTR", "RTL"))+
scale_x_discrete(labels = c ("British Partcipants" , "Saudi Partcipants"))+
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(size = 24, hjust = 0.5, face = "bold"),
axis.text.x = element_text(size = 16, face = "bold"),
axis.text.y = element_text(size = 16),
legend.title = element_text(size = 20),
legend.text = element_text(size = 20),
legend.key.size = unit(2, "lines") ,
legend.position = "top"
)
